1. Line 12 will print 3 because i is updated and then checked
2. Line 13 will print 150 because that is the discounted price of the last item on the list since finalPrice is updated each time
3. Line 14 will print 150 because the value of the variable is still the discounted price of the last tiem on the list
4. The function will return a list [50, 100, 150] which is a list of the discounted prices
5. The code causes an error because i cannot be accessed outside of the code block
6. The code causes an error because the variable discountedPrice cannot be accessed out of the code block since it was initialized by the let keyword
7. Line 14 will print 150 because the variable was initialized in the same code block so it keeps the discounted value of the last item
8. The function will return a list of the discounted prices [50, 100, 150] because the list of initialized in the same code block so values will be added and stored in the whole function
9. We will get an error because i is not defined in that code block
10. Line 12 will print 3 because that is the length of the input list
11. Returns a list [50, 100, 150] of discounted prices; even though it was initialized as a const variable it can still be changed, ie. we were still able to add the discounted prices to it
12. 
    - student.name
    - student['Grad Year']
    - student.greeting()
    - student['Favorite Teacher'].name
    - student.courseload[0]
13. 
    - '32' because integers map to string interpretations
    - 1 becasue you cannot substract from string so javascript converts 3 to a number
    - 3 becasue it adds nothing
    - 3null because it concatenates the word null to the string
    - 4 because it maps true to 1
    - 0 because false maps to 0 and null adds nothing
    - 3undefined because it concatenates to the string
    - NaN because you cannot subtract from a string
14.   
    - True; javascript maps 2 to a number
    - False; because you cannot comare strings like that
    - True; because it maps the string 2 to the integer 2 
    - False; because === checks datatype to compare
    - False; because 1 does not equal 2
    - True; because its both booleans
15. == is used to compare two variable but datatype is not checked whereas === is used to compare two variable but also checks to be sure the datatypes are the same.

16. (other file)
17. The result of this function will be the list [2, 4, 6] because the function doSomething will be applied to each item in the list. DoSomething multiplies each number by 2, thus modifyArray adds all the doubled numbers to the returned array.
18. (other file)
19. 1
4
3
2
